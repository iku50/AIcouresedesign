# A*算法基本思想

A算法：在图或树搜索中，如果搜索的每一步都利用估价函数：

$$
f(n)=g(n)+h(n)
$$

对 OPEN 表中的节点排序，则该搜索算法为A算法。

这里说一下所谓A算法实际上属于状态空间搜索。

## 状态空间搜索

1. 将给定的初始状态S_0作为当前状态(节点)，对其进行扩展(控制符操作)，生成一组子状态(子节点)。
2. 检查要求达到的目标状态S_g是否在这些子状态(子节点)中出现？
   ◇出现，搜索成功，找到问题的解。
   ◇未出现，则按某种搜索策略(盲目/启发)，从已生成的子状态(子节点)中
   再选择一个状态(节点)作为当前状态(节点)继续扩展。
3. 重复上述过程，直到子状态(子节点)中出现目标状态S_g，或者没有可继续扩展的节点为止。

"扩展"：对该节点施加某个可用的操作生成该节点的一组子节点。

OPEN 表：未扩展节点表，存放新生成且尚未扩展的节点(状态)。

CLOSED 表：已扩展节点表，存放已扩展或将要扩展的节点(状态)。

$S_0$ ：初始状态（起始节点\根节点）

G：通过搜索过程得到的搜索树

M：表示当前扩展节点是新生成且不是自己先辈的子节点集合

## 图搜索

一种在图(树)中寻找路径的方法
初始节点：初始数据库\初始状态集\初始节点集
目标节点：满足终止条件时的目标数据库\目标状态集\目标节点集
将初始节点变换为目标节点的规则序列问题，等价于求得图(树)中的一条路径(解路径)问题。

1. 将初始节点S0放入未扩展节点表(OPEN表)，建立当前仅包含S0的图G；
2. 检查OPEN表是否为空，若为空，则问题无解，失败退出；
3. 若不为空，即将OPEN表的第一个节点取出放入已扩展节点表CLOSED表，
   并标记该节点为节点n；
4. 考查节点n是否为目标节点。若是，即得到解，成功退出。
   解即为图G中，从n到S0的路径(回溯)。
5. 若不是，则扩展节点n，生成一组子节点。将其中不是节点n先辈的那
   部分子节点记入集合M，并将这组子节点作为节点n的子节点加入G中。
   (即在图中呈现出来)。
6. 针对集合M中子节点的不同情况，分别作如下处理：
   1. 对那些未在G中出现过的M成员，设置一个指向其父节点(即
      节点n)的指针，并将其放入OPEN表。（新生成的子节点→添加）
   2. 对原来已在G中出现过，但还未被扩展的M成员，确定是否需
      要修改它指向父节点的指针。(已生成、未扩展)（其新生成节点的父节点应由初始节点到新生成节点路径上的代价决定)
   3. 对先前已在G中出现过，并已扩展的M成员，确定是否需要修
      改其后继节点指向父节点的指针。(已经扩展→后继)
7. 按某种策略,对OPEN表中的节点进行排序。
8. 转第(2)步。

上述过程是状态空间的一般图搜索算法，后续的各种状态空间搜索策略可以视作此过程的特例

各种搜索策略的主要区别是对OPEN表的节点排序不同。

如宽度优先搜索是将先生成的子节点排在前面，深度优先搜索是将后生成的子节点排在前面

宽度优先搜索的OPEN表是队列

深度优先搜索的OPEN表是栈

上面两种盲目性较高，只适合求解简单问题

启发信息分类：

1. 确定下一个应扩展的节点，即最有希望的节点，避免出现宽度/深度优先搜索中盲目扩展节点。
2. 决定生成哪些后继节点，扩展某个节点过程中，决定应生成该节点的哪些后继
   节点，避免盲目生成所有节点。
3. 扩展某个节点时，决定哪些节点可从搜索树上删除。

利用上述第一种启发信息的状态空间搜索算法，即选择 “最有希望”的节点，作为下一个被扩展的节点，称为

## 有序搜索(Ordered search)。

估算节点希望程度(重要性)的指标---估价函数

一般形式： f(x)= g(x)+h(x) 或  f(n)= g(n)+h(n)

g(n)---从初始节点S0到某个节点n的代价 (代价函数)
h(n)---启发函数 (启发信息)启发信息即未来估计还需付出的代价

有序搜索：又称“最佳优先搜索”

思想：总是选择最有希望的节点作为下一个要扩展的节点

本质：选择OPEN表中具有最小f值的节点，作为下一个要扩展的节点。(在OPEN表中对节点按f值由小到大排序)

估价函数f的意义：一个节点的希望程度越大，其f值就越小。

结论：被选为扩展的节点，总是估价函数值f最小的节点。

算法的有效性直接取决于f,是提高搜索效率的关键。

若f不准确，可能失去最佳解，也可能失去全部解。

## A算法类型

根据搜索过程中，选择拟扩展节点的范围，A算法可分为：

1. 全局择优搜索算法
   从OPEN表的所有节点中，选择估价函数值最小的节点扩展。
2. 局部择优搜索算法
   仅从刚生成的子节点中，选择估价函数值最小的子节点扩展。

## A*算法

定义：对A算法中的估价函数f(n)=g(n)+h(n)加上某些限制，得到的一种启发式搜索算法。

思想：设f*(n)是从初始节点出发，经过节点n到达目标节点的最小代价。

原理：将估价函数f(n)看成对f*(n)的估计值，则有f*(n)=g*(n)+h*(n)

由此，A*算法对A算法中的g(n)、h(n)分别提出如下限制：

1. g(n)是对最小代价g*(n)的估计，且g(n)>0；
2. h(n)是最小代价h*(n)的下限，即对任意节点n均有h(n)≤h*(n)。

满足①、②两条限制的A算法称为A*算法。

**定义1**  在图搜索过程中，若重排OPEN表是根据f(n)=g(n)+h(n)进行的，
            则称该过程为A算法。

**定义2**  A算法中，若所有的n均存在h(n)≤h*(n)，则称h(n)为h*(n)的下限，
            表示某种偏于保守的估计。

**定义3**  采用h*(n)的下限h(n)为启发函数的A算法，称为A*算法。
            当h=0时，A*算法则变为等代价搜索算法。

## 代价树

某些应用并不要求操作序列为最少的解(最优)，而是要求具有某些特性的解(满足要求的解)。
定义：是宽度优先搜索的一种推广
      ◇不是沿等长度路径扩展，而是沿等代价路径扩展。
      ◇搜索树中，每条连接弧线上，均标有代价、时间、距离等标识。
算法应用条件：针对代价树的算法，算法对图进行搜索，须先将图转换为代价树。
