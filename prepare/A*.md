# A*算法基本思想

A算法：在图或树搜索中，如果搜索的每一步都利用估价函数：

$$
f(n)=g(n)+h(n)
$$

对 OPEN 表中的节点排序，则该搜索算法为A算法。

这里说一下所谓A算法实际上属于状态空间搜索。

状态空间搜索：

1. 将给定的初始状态S_0作为当前状态(节点)，对其进行扩展(控制符操作)，生成一组子状态(子节点)。
2. 检查要求达到的目标状态S_g是否在这些子状态(子节点)中出现？
   ◇出现，搜索成功，找到问题的解。
   ◇未出现，则按某种搜索策略(盲目/启发)，从已生成的子状态(子节点)中
   再选择一个状态(节点)作为当前状态(节点)继续扩展。
3. 重复上述过程，直到子状态(子节点)中出现目标状态S_g，或者没有可继续扩展的节点为止。

"扩展"：对该节点施加某个可用的操作生成该节点的一组子节点。

OPEN 表：未扩展节点表，存放新生成且尚未扩展的节点(状态)。

CLOSED 表：已扩展节点表，存放已扩展或将要扩展的节点(状态)。

$S_0$ ：初始状态（起始节点\根节点）

G：通过搜索过程得到的搜索树

M：表示当前扩展节点是新生成且不是自己先辈的子节点集合

图搜索：一种在图(树)中寻找路径的方法
初始节点：初始数据库\初始状态集\初始节点集
目标节点：满足终止条件时的目标数据库\目标状态集\目标节点集
将初始节点变换为目标节点的规则序列问题，等价于求得图(树)中的一条路径(解路径)问题。

1. 将初始节点S0放入未扩展节点表(OPEN表)，建立当前仅包含S0的图G；
2. 检查OPEN表是否为空，若为空，则问题无解，失败退出；
3. 若不为空，即将OPEN表的第一个节点取出放入已扩展节点表CLOSED表，
   并标记该节点为节点n；
4. 考查节点n是否为目标节点。若是，即得到解，成功退出。
   解即为图G中，从n到S0的路径(回溯)。
5. 若不是，则扩展节点n，生成一组子节点。将其中不是节点n先辈的那
   部分子节点记入集合M，并将这组子节点作为节点n的子节点加入G中。
   (即在图中呈现出来)。
